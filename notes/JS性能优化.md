内存管理  

垃圾回收  

GC算法  

引用计数算法实现原理 
设置引用数，判断当前引用数是否为0  
引用计数器

引用计数器算法优点：
- 发现垃圾时立即回收
- 最大限度减少程序暂停  

缺点：
- 无法回收循环引用的对象  
- 时间开销大  

标记清除算法实现原理  
分为标记和清除2个阶段  
1. 遍历所有对象找到活动对象并标记  
2. 遍历所有对象清除没有标记的对象，并把标记抹去，方便下次标记  
3. 回收没有标记的对象相应的空间  

标记清除算法的优缺点：  
优点：  
- 可以解决对象循环引用的无法回收的问题，由是否可达来判断是否需要回收  

缺点：  
- 回收的空间在地址上不一定连续，后续申请空间时可能会造成浪费  

标记整理算法  
可以看作是标记清除的增强，在标记阶段的操作和标记清除一致，与标记清除算法不同的是：  
在清除阶段，会先执行整理，移动对象位置，使其在内存地址上连续  

常见GC算法总结  
- 引用计数  
  - 可以即时回收垃圾对象  
  - 减少程序卡顿的时间：即时回收，在程序内存即将占满时，可以及时清理  
  - 无法回收循环引用的对象  
  - 对资源消耗较大：需要维护引用计数器
- 标记清除  
    - 可以回收循环引用的对象  
    - 容易产生碎片化空间，浪费空间  
    - 不会立即回收垃圾对象，需要等待整个标记过程结束后再开始清除，同时在清除过程中，程序是停止工作的
- 标记整理  
    - 减少碎片化空间  
    - 不会立即回收垃圾对象  

V8引擎  
特性：  
- 采用即时编译，之前别的引擎是采用的预编译，需要将代码先转换成字节码
- 内存设限：64位操作系统：1.5G，32位操作系统：800M，一方面V8是为浏览器设计的，这个内存大小已经足够了，另一方面，V8的垃圾回收机制，当垃圾内存达到1.5G时，采用增量标记进行垃圾回收需要50ms，采用非增量标记回收需要1s

V8垃圾回收策略  
采用分代回收的思想，内存分为新生代、老生代，针对不同对象采用不同算法  

V8中用到的GC算法：  
- 分代回收  
- 空间复制  
- 标记清除
- 标记整理
- 标记增量

V8如何回收新生代对象  
内存分为两部分：新生代【From，To】，老生代  
新生代指存活时间较短的对象  
新生代对象回收实现：  
- 采用复制算法+标记整理  
- 新生代内存分为等大的两个空间
- 使用空间为From，空闲空间为To  
- 活动对象存储于From空间
- 标记整理后将活动对象拷贝至To
- From与To交换空间完成释放  

回收细节说明：

- 拷贝过程中新生代对象可能会晋升至老生代
- 出现晋升的情形：
    1. 一轮GC后还存活的新生代需要晋升
    2. To空间的使用率超过25%  

V8如何回收老生代对象  
老生代区域空间限制：64位OS 1.4G，32位OS 700M  
老生代对象就是指存活时间较长的对象  

老生代对象回收的实现：  
- 主要采用标记清除、标记整理、增量标记算法  
- 主要使用标记清除完成垃圾空间的回收，标记清除效率高  
- 采用标记整理进行空间优化，在新生代晋升至老生代时，如果老生代区域不足时，会进行标记整理，进行空间优化
- 采用增量标记进行回收效率优化  

新老生代回收细节对比  
- 新生代使用空间换时间，将内存空间一分为二，在任一时刻总有一半空间是空闲着的，但新生代使用的空间比较小（64位32M，32位16M），所以比较合适
- 老生代区域垃圾回收不适合复制算法，老生代对象多，占用空间大，复制算法耗时长

标记增量如何优化垃圾回收  
标记行为会阻塞程序执行，遍历对象进行标记时程序并不在执行，那么将标记的过程拆分为很多步骤，和程序执行交替执行，这就是增量标记算法，在全部对象都被标记后，再进行清除  
当内存使用接近最大值时，使用标记整理算法进行垃圾回收，官方测试需要1s的时间  

V8垃圾回收总结
- V8是一款主流的JS执行引擎  
- V8内存设置上限，主要由于1. V8专门为浏览器设计，内存使用不需要很大，2. 由于V8内部的垃圾回收机制，如果使用的内存太大，内存回收时间太长会造成用户感知
- V8基于分代回收实现垃圾回收  
- V8内存分为新生代和老生代  
- V8垃圾回收常见的GC算法：针对新生代采用复制算法和标记整理算法，针对老生代使用标记清除、标记整理、增量标记算法

Performance工具介绍

Performance使用步骤：  
  1. 打开浏览器输入目标网址，不打开，只输入  
  2. 进入开发人员工具面板，选择性能  
  3. 开启录制功能，访问具体界面  
  4. 执行用户行为，一段时间后停止录制  
  5. 分析界面中记录的内存信息  

内存问题的体现：  
- 页面出现延迟加载或经常性暂停（频繁进行GC）
- 页面持续性出现糟糕的性能（内存膨胀，申请内存空间超过了设备能提供的内存大小）
- 页面的性能随时间延长越来越差（内存泄漏）

监控内存的几种方式  

界定内存问题的标准  
- 内存泄露：内存使用持续升高  
- 内存膨胀：需要判断是设备的问题还是程序的问题，在多数设备上都存在性能问题  
- 频繁GC：通过内存变化图进行分析  

监控内存的几种方式  
- 浏览器任务管理器
- Timeline时序图记录
- 堆快照查找分离DOM（内存泄漏）
- 判断是否存在频繁的垃圾回收  


任务管理器监控内存  

Timeline记录内存

堆快照查找分离DOM  

分离DOM：
    - 界面元素都存活在DOM树上
    - 当DOM节点脱离DOM树，并且JS中没有任何变量引用这个DOM，那么它就是垃圾对象，需要被回收  
    - 分离DOM就是指脱离DOM树的DOM元素，但是JS中有变量仍然引用着这个DOM元素

堆快照拍照后筛选Detached HTMLElement
