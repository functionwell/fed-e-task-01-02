内存管理

垃圾回收

GC 算法

引用计数算法实现原理
设置引用数，判断当前引用数是否为 0  
引用计数器

引用计数器算法优点：

- 发现垃圾时立即回收
- 最大限度减少程序暂停

缺点：

- 无法回收循环引用的对象
- 时间开销大

标记清除算法实现原理  
分为标记和清除 2 个阶段

1. 遍历所有对象找到活动对象并标记
2. 遍历所有对象清除没有标记的对象，并把标记抹去，方便下次标记
3. 回收没有标记的对象相应的空间

标记清除算法的优缺点：  
优点：

- 可以解决对象循环引用的无法回收的问题，由是否可达来判断是否需要回收

缺点：

- 回收的空间在地址上不一定连续，后续申请空间时可能会造成浪费

标记整理算法  
可以看作是标记清除的增强，在标记阶段的操作和标记清除一致，与标记清除算法不同的是：  
在清除阶段，会先执行整理，移动对象位置，使其在内存地址上连续

常见 GC 算法总结

- 引用计数
  - 可以即时回收垃圾对象
  - 减少程序卡顿的时间：即时回收，在程序内存即将占满时，可以及时清理
  - 无法回收循环引用的对象
  - 对资源消耗较大：需要维护引用计数器
- 标记清除
  - 可以回收循环引用的对象
  - 容易产生碎片化空间，浪费空间
  - 不会立即回收垃圾对象，需要等待整个标记过程结束后再开始清除，同时在清除过程中，程序是停止工作的
- 标记整理
  - 减少碎片化空间
  - 不会立即回收垃圾对象

V8 引擎  
特性：

- 采用即时编译，之前别的引擎是采用的预编译，需要将代码先转换成字节码
- 内存设限：64 位操作系统：1.5G，32 位操作系统：800M，一方面 V8 是为浏览器设计的，这个内存大小已经足够了，另一方面，V8 的垃圾回收机制，当垃圾内存达到 1.5G 时，采用增量标记进行垃圾回收需要 50ms，采用非增量标记回收需要 1s

V8 垃圾回收策略  
采用分代回收的思想，内存分为新生代、老生代，针对不同对象采用不同算法

V8 中用到的 GC 算法：

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量

V8 如何回收新生代对象  
内存分为两部分：新生代【From，To】，老生代  
新生代指存活时间较短的对象  
新生代对象回收实现：

- 采用复制算法+标记整理
- 新生代内存分为等大的两个空间
- 使用空间为 From，空闲空间为 To
- 活动对象存储于 From 空间
- 标记整理后将活动对象拷贝至 To
- From 与 To 交换空间完成释放

回收细节说明：

- 拷贝过程中新生代对象可能会晋升至老生代
- 出现晋升的情形：
  1. 一轮 GC 后还存活的新生代需要晋升
  2. To 空间的使用率超过 25%

V8 如何回收老生代对象  
老生代区域空间限制：64 位 OS 1.4G，32 位 OS 700M  
老生代对象就是指存活时间较长的对象

老生代对象回收的实现：

- 主要采用标记清除、标记整理、增量标记算法
- 主要使用标记清除完成垃圾空间的回收，标记清除效率高
- 采用标记整理进行空间优化，在新生代晋升至老生代时，如果老生代区域不足时，会进行标记整理，进行空间优化
- 采用增量标记进行回收效率优化

新老生代回收细节对比

- 新生代使用空间换时间，将内存空间一分为二，在任一时刻总有一半空间是空闲着的，但新生代使用的空间比较小（64 位 32M，32 位 16M），所以比较合适
- 老生代区域垃圾回收不适合复制算法，老生代对象多，占用空间大，复制算法耗时长

标记增量如何优化垃圾回收  
标记行为会阻塞程序执行，遍历对象进行标记时程序并不在执行，那么将标记的过程拆分为很多步骤，和程序执行交替执行，这就是增量标记算法，在全部对象都被标记后，再进行清除  
当内存使用接近最大值时，使用标记整理算法进行垃圾回收，官方测试需要 1s 的时间

V8 垃圾回收总结

- V8 是一款主流的 JS 执行引擎
- V8 内存设置上限，主要由于 1. V8 专门为浏览器设计，内存使用不需要很大，2. 由于 V8 内部的垃圾回收机制，如果使用的内存太大，内存回收时间太长会造成用户感知
- V8 基于分代回收实现垃圾回收
- V8 内存分为新生代和老生代
- V8 垃圾回收常见的 GC 算法：针对新生代采用复制算法和标记整理算法，针对老生代使用标记清除、标记整理、增量标记算法

Performance 工具介绍

Performance 使用步骤：

1. 打开浏览器输入目标网址，不打开，只输入
2. 进入开发人员工具面板，选择性能
3. 开启录制功能，访问具体界面
4. 执行用户行为，一段时间后停止录制
5. 分析界面中记录的内存信息

内存问题的体现：

- 页面出现延迟加载或经常性暂停（频繁进行 GC）
- 页面持续性出现糟糕的性能（内存膨胀，申请内存空间超过了设备能提供的内存大小）
- 页面的性能随时间延长越来越差（内存泄漏）

监控内存的几种方式

界定内存问题的标准

- 内存泄露：内存使用持续升高
- 内存膨胀：需要判断是设备的问题还是程序的问题，在多数设备上都存在性能问题
- 频繁 GC：通过内存变化图进行分析

监控内存的几种方式

- 浏览器任务管理器
- Timeline 时序图记录
- 堆快照查找分离 DOM（内存泄漏）
- 判断是否存在频繁的垃圾回收

任务管理器监控内存

Timeline 记录内存

堆快照查找分离 DOM

分离 DOM： - 界面元素都存活在 DOM 树上 - 当 DOM 节点脱离 DOM 树，并且 JS 中没有任何变量引用这个 DOM，那么它就是垃圾对象，需要被回收

- 分离 DOM 就是指脱离 DOM 树的 DOM 元素，但是 JS 中有变量仍然引用着这个 DOM 元素

堆快照拍照后筛选 Detached HTMLElement

如何确定频繁 GC

1. Timeline 中频繁的上升下降
2. 任务管理器中数据频繁的增加减小

Performance 工具总结

代码优化介绍

如何精准测试 JS 性能  
使用基于 Benchmark.js 的[https://jsperf.com/](https://jsperf.com/)

jsper 使用流程

1. 登录
2. 填写详细的测试用例信息
3. 填写准备代码
4. 填写必要的 setup 和 teardown 代码
5. 填写测试代码片段

慎用全局变量  
why：

- 全局变量定义在全局执行上下文，是所有作用域的顶端，基于作用域链的查找最后才会查找到这里
- 全局执行上下文一直存在于上下文执行栈，直到程序退出，不会被 GC 回收
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局变量

通过原型新增方法

- 在原型对象上新增实例对象需要的方法，而不是在实例中定义方法

避免属性访问方法使用  
属性访问方法：get，set

- JS 不需要属性访问方法，所有属性都是外部可见的
- 使用属性访问方法只会增加一层重定义，没有访问的控制力

```javascript
// 效率低
function Person() {
  this.name = 'Tom';
  this.age = 18;
  this.getAge = function () {
    return this.age;
  };
}
const p1 = new Person();
const a = p1.getAge();
// 效率高
function Person2() {
  this.name = 'Tom';
  this.age = 18;
}
const p2 = new Person();
const b = p2.age;
```

for 循环优化

```javascript
var arr = [];
arr[10000] = 'Tom';
// 效率低
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// 效率高
for (var i = arr.length; i; i--) {
  console.log(arr[i]);
}
```

节点添加优化  
使用 document.createDocumentFragment 创建 DOM 片段，然后整体添加到 DOM 树上
 
 克隆优化节点操作  
 当需要新增节点时，可以克隆一个已经存在的同样节点，再修改属性，比重新创建一个节点设置各个属性要性能高  

 直接量替换new Object  

 