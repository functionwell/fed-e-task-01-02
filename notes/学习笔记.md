-   函数式编程

    把运算过程抽象到程序中  
     函数是指数学中的函数，即映射关系  
     相同的输入要有相同的输出  
     一等公民函数，函数是普通对象  
     高阶函数，把函数作为参数传给另一个函数，也可以将函数作为返回结果  
     返回一个函数的应用，once，只支付一次，外层函数定义 done，标记是否执行，内层函数改变 done，并执行传入的函数

    ```javascript
    function once(fn) {
        let done = false;
        return function () {
            if (!done) {
                done = true;
                return fn.apply(this, arguments);
            }
        };
    }
    ```

    常用的高阶函数  
    map, every, some

-   闭包

    本质：函数在执行的时候会放到一个执行栈上，当函数执行完后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员

-   纯函数

    相同的输入永远会得到相同的输出，而且没有任何可观察的副作用  
     函数式编程不会保留中间结果，所以变量是不可变的（无状态的）

    优势：结果可缓存；可测试；方便并行处理

-   函数的副作用

    函数依赖外部的状态时无法保证相同的输出，就会产生副作用  
     副作用来源：配置文件，数据库，用户的输入...

-   柯里化

    当一个函数有多个参数的时候先传递一部分参数给它，这部分参数以后永远不变，然后返回一个新的函数接受剩余参数，返回结果  
     lodash \_.curry  
     实现原理

    ```javascript
    function curry(fn) {
        return function curried(...args) {
            if (args.length < fn.length) {
                return function (...args2) {
                    return curried(...args.concat(args2));
                };
            }
            return fn(...args);
        };
    }
    ```

    柯里化可以给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数  
    柯里化是对函数参数的一种缓存  
    让函数变得更灵活，让函数的颗粒度更小

-   函数组合  
     纯函数和柯里化很容易写出洋葱代码，函数组合可以解决这个问题  
     如果一个函数需要经过多个函数处理才嫩得到最终值，这个时候可以把中间过程的函数合并成一个函数  
     函数就像数据管道，让数据穿过多个管道形成最终结果  
     默认是从右到左执行  
     lodash 的组合函数 flow, flowRight  
     组合函数原理模拟：

    ```javascript
    function compose(...args) {
        return function (value) {
            return args.reduceRight((acc, fn) => {
                return fn(acc);
            }, value);
        };
    }

    const compose = (...args) => (value) =>
        args.reduceRight((acc, fn) => fn(acc), value);
    ```

    函数组合的结合律：  
     既可以先组合 f 和 g，再组合 h，也可以把 f 跟 g 和 h 的组合结果相组合，两种方式等效

    函数组合的调试：

    ```javascript
    const trace = _.curry((tag, v) => {
        console.log(tag, v);
        return v;
    });

    _.flowRight(
        join('-'),
        trace('map之后'),
        map(_.toLower),
        trace('split之后'),
        split(' ')
    );
    ```
lodash的fp模块

fp模块提供了函数式编程友好的方法，提供了不可变的auto-curried iteratee-first data-last的方法  
fp中map的区别：  
    普通map的第2个参数会接受到3个参数：value, index, arr  
    fp中的map第一个参数中只会接收到当前value  

point free模式：就是函数组合

把数据处理的过程，定义成数据无关的的合成运算，**不需要用到代表数据的那个参数**，只要把简单的运算步骤**合成**到一起，用这种模式之前**需要定义一些辅助的基本运算函数**
